#
# U.S. Naval Research Laboratory
# Center for High Assurance Computer Systems
#
from abc import ABCMeta, abstractmethod
from libStealthy.exceptions import EncodingError
import warnings

class BaseStegoConstructDist(object, metaclass=ABCMeta):
    '''
    Construct a fresh IPD sequence that encodes msg, given as an iterable from {'0','1'}*, given a distribution as a coverDistObj object when the BaseStegoConstructDist (or sub-class) object is constructed.
    '''

    @abstractmethod
    def generateIPDseq(self, numt, coverDistObj, msg):
        pass


class SellkeBasicStegoConstruct(BaseStegoConstructDist):
    '''
    Basic class for using L-bits-to-n-IPDs code following sellke2009tcp.

    Nothing is done to match an existing distribution.

    The BaseStegoConstructDist given when this is constructed is used to pad out the IPD sequence produced by generateIPDseq method if the requested number of IPDs is greater than the number required to encode the message.
    '''

    def __init__(self, L, n, D, d, L2nCodebook):
        self.L = L
        self.n = n
        self.BigDelta = D
        self.delta = d
        self.codebook = L2nCodebook

        if self.L != self.codebook.L or self.n != self.codebook.n:
            raise ValueError('Codebook parameters do not match stego-object parameters!')

    def generateIPDseq(self, numt, coverDistObj, msg):
        '''
        ...

        This will only use the coverDistObj if needed to pad out to numt IPDs.
        '''

        # Go through msg L bits at a time
        # Encode those L bits using the codebook
        # Convert the returned vector to IPDs

        # Handle bad lengths
        #

        # Number of L-bit blocks in the message
        numBlocks = len(msg) / self.L
        if numBlocks * self.L < len(msg):
            numBlocks += 1
        if numt < numBlocks * self.n:
            raise EncodingError('Message too long for requested number of IPDs!')

        IPDs = []

        for i in range(0, int(len(msg)/self.L)*self.L, self.L):
            frag = msg[i:i+self.L]
            fragStr = ''
            for c in frag:
                fragStr += c
            kvec = self.codebook.encodeMsg(fragStr)
            IPDfrag = []
            for k in kvec:
                IPDfrag.append(self.BigDelta + k*self.delta)
            IPDs += IPDfrag

        # Check whether the last fragment exhausted the message; if not, catch the tail
        if i + self.L - 1 < len(msg) - 1:
            tail = msg[i+self.L:]
            if len(tail) > self.L:
                raise ValueError('Message tail is too long!')
            tailStr = ''
            for c in tail:
                tailStr += c
            if len(tailStr) < self.L:
                padLen = self.L - len(tailStr)
                tailStr += '0' * padLen
                kvec = self.codebook.encodeMsg(tailStr)
                IPDfrag = []
                for k in kvec:
                    IPDfrag.append(self.BigDelta + k*self.delta)
                IPDs += IPDfrag

            else:
                warnings.warn('Message tail is of length L!', RuntimeWarning)

        return IPDs

class SellkeUEBasicStegoConstruct(BaseStegoConstructDist):
    '''
    Basic class for using L-bits-to-n-IPDs code following sellke2009tcp.

    The generateIPDseq method generates an IPD sequence using the coverDistObj provided when this object is constructed and then replaces some of those IPDs using the IPDs generated by encoding (according to the L-to-n codebook provided at object construction) the message into IPDs.

    The stego IPDs (i.e., those encoding the message) are put at the beginning of the IPD sequence.  If the sender and receiver share an offset and delta, the modified IPDs could be spread more uniformly throughout the cover IPDs.
    '''

    def __init__(self, L, n, D, d, L2nCodebook):
        self.L = L
        self.n = n
        self.BigDelta = D
        self.delta = d
        self.codebook = L2nCodebook

        if self.L != self.codebook.L or self.n != self.codebook.n:
            raise ValueError('Codebook parameters do not match stego-object parameters!')

    def generateIPDseq(self, numt, coverDistObj, msg, offset=0, dl=1):
        '''
        Generate numt IPDs using coverDistObj, insert msg uniformly within that.

        offset (default: 0) is the number of IPDs before first stego IPD
        '''

        # Go through msg L bits at a time
        # Encode those L bits using the codebook
        # Convert the returned vector to IPDs

        # Handle cases where len(msg) is not a multiple of self.L

        # Number of L-bit blocks in the message
        numBlocks = len(msg) / self.L
        if numBlocks * self.L < len(msg):
            numBlocks += 1
        if numt < (numBlocks * self.n - 1) * dl + offset + 1:
            raise EncodingError('Message length/spacing too large for requested number of IPDs!')


        msgIPDs = []

        lastStart = 0

        for i in range(0, int(len(msg)/self.L)*self.L, self.L):
            frag = msg[i:i+self.L]
            fragStr = ''
            for c in frag:
                fragStr += c
            kvec = self.codebook.encodeMsg(fragStr)
            IPDfrag = []
            for k in kvec:
                IPDfrag.append(self.BigDelta + k*self.delta)
            msgIPDs += IPDfrag
            lastStart = i

        # Check whether the last fragment exhausted the message; if not, catch the tail
        if lastStart + self.L - 1 < len(msg) - 1:
            tail = msg[lastStart+self.L:]
            if len(tail) > self.L:
                raise ValueError('Message tail is too long!')
            tailStr = ''
            for c in tail:
                tailStr += c
            if len(tailStr) < self.L:
                padLen = self.L - len(tailStr)
                tailStr += '0' * padLen
                kvec = self.codebook.encodeMsg(tailStr)
                IPDfrag = []
                for k in kvec:
                    IPDfrag.append(self.BigDelta + k*self.delta)
                msgIPDs += IPDfrag

            else:
                warnings.warn('Message tail is of length L!', RuntimeWarning)


        # Generate cover IPDs, then modify selected ones to embed the message
        IPDs = coverDistObj.generateIPDseq(numt)

        if offset + dl * (len(msgIPDs) - 1) > len(IPDs) - 1:
            raise EncodingError('Message spacing too large for requested number of IPDs!')

        for i in range(len(msgIPDs)):
            IPDs[offset + i * dl] = msgIPDs[i]

        return IPDs
